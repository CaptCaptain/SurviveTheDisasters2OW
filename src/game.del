enum GameState {
    WAITING_FOR_PLAYERS,
    BREAK_TIME,
    INTERMISSION,
    IN_BETWEEN,
    ROUND
}

globalvar DisasterData selectedDisaster;
globalvar Number disasterSelectIndex;
globalvar Number[] excludedDisasters;
globalvar Number disasterNameStringIndex;
globalvar String disasterNameString;
globalvar Boolean playersCanRespawnInDisaster = true;
globalvar String[] disasterNames = [];
globalvar GameState currentGameState = GameState.WAITING_FOR_PLAYERS;
globalvar Number roundDuration = 0;
globalvar Number currentRound = 0;

void updateDisasterString() "[game.del] Subroutine updateDisasterString" {
    LogToInspector(CountOf(disasterNames));
    if (CountOf(disasterNames) <= 1) {
        disasterNameString = disasterNames[0];
        disasterNames = [];
        return;
    }
    disasterNameString = disasterNames[0];
    for (disasterNameStringIndex = 1; CountOf(disasterNames) - 1; 1) {
        disasterNameString = disasterNameString + ", " + disasterNames[disasterNameStringIndex];
    }
    disasterNameString = disasterNameString + ", and " + disasterNames[CountOf(disasterNames) - 1];
    disasterNames = [];
    return;
}

void addDisaster() "[game.del] Subroutine addDisaster" {
    selectedDisaster = Disasters.getDisaster(disasterPool[disasterSelectIndex]);
    disasterNames.ModAppend(selectedDisaster.name);

    if (!selectedDisaster.playersCanRespawn)
        playersCanRespawnInDisaster = false;

    roundDuration = selectedDisaster.duration;

    Disasters.addDisaster(selectedDisaster);
}

void addRandomDisaster() "[game.del] Subroutine addRandomDisaster" {
    selectedDisaster = Disasters.getDisaster(disasterPool.Remove(activeDisasters).Random());
    excludedDisasters.ModAppend(selectedDisaster.excludedDisasters);

    Boolean selectedDisasterIsExcluded = excludedDisasters.Contains(selectedDisaster.id);

    if (selectedDisaster == null || selectedDisasterIsExcluded) return;
    disasterNames.ModAppend(selectedDisaster.name);
    Disasters.addDisaster(selectedDisaster);
    roundDuration = roundDuration + selectedDisaster.duration / 2;
    roundDuration = Min(30, roundDuration);
}

class Game {
    public static void setup() {
        DisableCompletion();
        DisableAnnouncer();
        while (IsWaitingForPlayers())
        {
            StartGameMode();
            Wait(0.016);
        }
        SetMatchTime(15);
        StartDamageModification(AllPlayers(Team.Team1), AllPlayers(Team.Team2), 50, DamageModificationRev.ReceiversAndDamagers);
        disasterSelectIndex = 0;
    }

    public static void breakTime() {
        currentGameState = GameState.BREAK_TIME;
        currentRound += 1;
        #HeroInfo.showInfo();
        SetTeamScore(Team.Team2, 20);
        WaitUntil(IsGameInProgress(), 9999);
        Hud.updateDescription("Get Ready");
        SetMatchTime(45);
        Wait(0.016);
        ReadyUp.start();
        WaitUntil(MatchTime() <= 0, 9999);
    }

    public static void intermission() {
        currentGameState = GameState.INTERMISSION;
        currentRound += 1;

        #HeroInfo.showInfo();
        WaitUntil(IsGameInProgress(), 9999);

        if (currentRound % GameSettings.specialRound == 0) {
            currentGameState = GameState.IN_BETWEEN;
            BigMessage(AllPlayers(Team.Team1), "Warning!!!");
            Hud.updateDescription("");
            Hud.updateTimerString("");
            Wait(3.5);
            currentGameState = GameState.INTERMISSION;
            Hud.updateDescription("Warning!!!");
        } else {
            Hud.updateDescription("Next Disaster In");
        }

        SetMatchTime(30);
        Wait(0.016);
        ReadyUp.start();
        WaitUntil(MatchTime() <= 0, 9999);
    }

    public static void results() {
        currentGameState = GameState.IN_BETWEEN;

        Hud.updateDescription("Results");
        Hud.updateTimerString("");

        Player[] livingPlayers: AllLivingPlayers(Team.Team1).Filter(player => !player.isDeadInRound);
        BigMessage(livingPlayers, "Survived!");
        
        // Local Player does not work with PlayEffect
        PlayEffect(livingPlayers[0], PlayEffect.BuffExplosionSound, Team.All, livingPlayers[0].Position(), 10000);
        PlayEffect(livingPlayers[1], PlayEffect.BuffExplosionSound, Team.All, livingPlayers[1].Position(), 10000);
        PlayEffect(livingPlayers[2], PlayEffect.BuffExplosionSound, Team.All, livingPlayers[2].Position(), 10000);
        PlayEffect(livingPlayers[3], PlayEffect.BuffExplosionSound, Team.All, livingPlayers[3].Position(), 10000);
        PlayEffect(livingPlayers[4], PlayEffect.BuffExplosionSound, Team.All, livingPlayers[4].Position(), 10000);
        PlayEffect(livingPlayers[5], PlayEffect.BuffExplosionSound, Team.All, livingPlayers[5].Position(), 10000);

        Player[] deadPlayers: AllPlayers(Team.Team1).Filter(player => player.isDeadInRound);
        BigMessage(deadPlayers, "Wipeout!");

        // Local Player does not work with PlayEffect
        PlayEffect(deadPlayers[0], PlayEffect.DebuffImpactSound, Team.All, deadPlayers[0].Position(), 10000);
        PlayEffect(deadPlayers[1], PlayEffect.DebuffImpactSound, Team.All, deadPlayers[1].Position(), 10000);
        PlayEffect(deadPlayers[2], PlayEffect.DebuffImpactSound, Team.All, deadPlayers[2].Position(), 10000);
        PlayEffect(deadPlayers[3], PlayEffect.DebuffImpactSound, Team.All, deadPlayers[3].Position(), 10000);
        PlayEffect(deadPlayers[4], PlayEffect.DebuffImpactSound, Team.All, deadPlayers[4].Position(), 10000);
        PlayEffect(deadPlayers[5], PlayEffect.DebuffImpactSound, Team.All, deadPlayers[5].Position(), 10000);

        // Heal players and refresh their cooldowns
        SetPlayerHealth(livingPlayers[0], MaxHealth(livingPlayers[0]));
        SetPlayerHealth(livingPlayers[1], MaxHealth(livingPlayers[1]));
        SetPlayerHealth(livingPlayers[2], MaxHealth(livingPlayers[2]));
        SetPlayerHealth(livingPlayers[3], MaxHealth(livingPlayers[3]));
        SetPlayerHealth(livingPlayers[4], MaxHealth(livingPlayers[4]));
        SetPlayerHealth(livingPlayers[5], MaxHealth(livingPlayers[5]));

        SetAbilityCooldown(livingPlayers, Button.PrimaryFire, 0);
        SetAbilityCooldown(livingPlayers, Button.SecondaryFire, 0);
        SetAbilityCooldown(livingPlayers, Button.Ability1, 0);
        SetAbilityCooldown(livingPlayers, Button.Ability2, 0);
        SetAbilityCooldown(livingPlayers, Button.Crouch, 0);

        Wait(3.5);

        if (currentRound >= GameSettings.maxRounds) {
            DeclareTeamVictory(Team.Team1);
        }
    }

    public static void selectDisaster() {
        addDisaster();
    }

    public static void selectRandomDisaster() {
        addRandomDisaster();
    }

    public static void startRound() {
        currentGameState = GameState.IN_BETWEEN;
        ReadyUp.end();
        HeroInfo.hideInfo();
        Hud.updateDescription("");
        Hud.updateTimerString("");

        if (currentRound % GameSettings.specialRound == 0) {
            while (CountOf(activeDisasters) < EvaluateOnce(RandomInteger(2, 3))) {
                selectRandomDisaster();
                Wait(0.016);
            }
            playersCanRespawnInDisaster = false;
        } else {
            selectDisaster();
        }
        Disasters.displayDisasters();
        updateDisasterString();

        if (!playersCanRespawnInDisaster) {
            AllPlayers(Team.Team1).canSpawn = false;
        }

        currentGameState = GameState.ROUND;
        Hud.updateDescription(disasterNameString);
        Disasters.startDisaster();
        SetMatchTime(roundDuration);
        Wait(0.016);
        WaitUntil(MatchTime() <= 0 || AllPlayers(Team.Team1).All(player => player.isDeadInRound), 9999);
        disasterSelectIndex += 1;

        if (disasterSelectIndex >= CountOf(disasterPool)) {
            disasterSelectIndex = 0;
        }
    }
}

rule: '[game.del] Setup Game'
{
    Game.setup();
    Game.breakTime();
    while (true) {
        Game.startRound();
        Disasters.endDisaster();
        playersCanRespawnInDisaster = true;
        AllPlayers(Team.Team1).canSpawn = true;
        Respawn(AllDeadPlayers(Team.Team1));
        roundDuration = 0;
        Game.results();
        AllPlayers(Team.Team1).isDeadInRound = false;
        Game.intermission();
        Wait(0.016);
    }
}

rule: '[game.del] Reduce Timer If Player Readies Up'
{
    WaitUntil(currentGameState == GameState.BREAK_TIME || currentGameState == GameState.INTERMISSION, 9999);
    WaitUntil(ReadyUp.numberOfPlayersReady() != EvaluateOnce(ReadyUp.numberOfPlayersReady()), 9999);
    if (ReadyUp.numberOfPlayersReady() >= NumberOfPlayers(Team.Team1)) SetMatchTime(Max(3, MatchTime() / 2));
    if (ReadyUp.allPlayersReady()) SetMatchTime(3);
    Wait(0.016);
    Loop();
}